<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ•ˆèƒ½å„ªåŒ–æ¸¬è©¦é é¢</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #1a1a1a;
        color: #e0e0e0;
        line-height: 1.6;
      }

      .test-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .test-section h2 {
        color: #66bb6a;
        margin-top: 0;
      }

      .metric {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .metric:last-child {
        border-bottom: none;
      }

      .metric-value {
        font-weight: bold;
        color: #90ee90;
      }

      .metric-value.warning {
        color: #ffa726;
      }

      .metric-value.error {
        color: #ef5350;
      }

      .button {
        background: linear-gradient(135deg, #66bb6a, rgba(102, 187, 106, 0.8));
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }

      .button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 187, 106, 0.3);
      }

      .log-container {
        background: #000;
        border-radius: 5px;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-good {
        background: #4caf50;
      }
      .status-warning {
        background: #ff9800;
      }
      .status-error {
        background: #f44336;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #66bb6a, #90ee90);
        width: 0%;
        transition: width 0.3s ease;
      }

      .recommendations {
        background: rgba(255, 193, 7, 0.1);
        border-left: 4px solid #ffc107;
        padding: 15px;
        margin: 15px 0;
      }

      .recommendations h3 {
        color: #ffc107;
        margin-top: 0;
      }

      .recommendations ul {
        margin: 0;
        padding-left: 20px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }
    </style>
  </head>
  <body>
    <h1>ğŸš€ CSS é—œéµè·¯å¾‘å„ªåŒ–æ¸¬è©¦</h1>

    <div class="test-section">
      <h2>ğŸ“Š å³æ™‚æ•ˆèƒ½æŒ‡æ¨™</h2>
      <div id="live-metrics">
        <div class="metric">
          <span>First Contentful Paint (FCP)</span>
          <span class="metric-value" id="fcp-value">æ¸¬é‡ä¸­...</span>
        </div>
        <div class="metric">
          <span>Largest Contentful Paint (LCP)</span>
          <span class="metric-value" id="lcp-value">æ¸¬é‡ä¸­...</span>
        </div>
        <div class="metric">
          <span>Cumulative Layout Shift (CLS)</span>
          <span class="metric-value" id="cls-value">æ¸¬é‡ä¸­...</span>
        </div>
        <div class="metric">
          <span>First Input Delay (FID)</span>
          <span class="metric-value" id="fid-value">ç­‰å¾…äº’å‹•...</span>
        </div>
        <div class="metric">
          <span>Time to First Byte (TTFB)</span>
          <span class="metric-value" id="ttfb-value">æ¸¬é‡ä¸­...</span>
        </div>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="overall-progress"></div>
      </div>
      <div style="text-align: center; margin-top: 10px">
        <span id="overall-grade">è©•ä¼°ä¸­...</span>
      </div>
    </div>

    <div class="grid">
      <div class="test-section">
        <h2>ğŸ”§ å„ªåŒ–åŠŸèƒ½æ¸¬è©¦</h2>
        <div id="optimization-status">
          <div class="metric">
            <span>é—œéµè·¯å¾‘å„ªåŒ–å™¨</span>
            <span class="metric-value" id="critical-path-status">
              <span class="status-indicator status-warning"></span>æª¢æŸ¥ä¸­...
            </span>
          </div>
          <div class="metric">
            <span>å»¶é²è¼‰å…¥æ©Ÿåˆ¶</span>
            <span class="metric-value" id="lazy-loader-status">
              <span class="status-indicator status-warning"></span>æª¢æŸ¥ä¸­...
            </span>
          </div>
          <div class="metric">
            <span>æ•ˆèƒ½ç›£æ§ç³»çµ±</span>
            <span class="metric-value" id="performance-monitor-status">
              <span class="status-indicator status-warning"></span>æª¢æŸ¥ä¸­...
            </span>
          </div>
        </div>

        <div style="margin-top: 20px">
          <button class="button" onclick="testCriticalPath()">
            æ¸¬è©¦é—œéµè·¯å¾‘
          </button>
          <button class="button" onclick="testLazyLoading()">
            æ¸¬è©¦å»¶é²è¼‰å…¥
          </button>
          <button class="button" onclick="generateReport()">ç”Ÿæˆå ±å‘Š</button>
          <button class="button" onclick="exportData()">åŒ¯å‡ºæ•¸æ“š</button>
        </div>
      </div>

      <div class="test-section">
        <h2>ğŸ“ˆ è³‡æºè¼‰å…¥çµ±è¨ˆ</h2>
        <div id="resource-stats">
          <div class="metric">
            <span>å·²è¼‰å…¥è³‡æº</span>
            <span class="metric-value" id="loaded-resources">0</span>
          </div>
          <div class="metric">
            <span>ç¸½å‚³è¼¸å¤§å°</span>
            <span class="metric-value" id="total-size">è¨ˆç®—ä¸­...</span>
          </div>
          <div class="metric">
            <span>CSS æª”æ¡ˆ</span>
            <span class="metric-value" id="css-count">0</span>
          </div>
          <div class="metric">
            <span>JavaScript æª”æ¡ˆ</span>
            <span class="metric-value" id="js-count">0</span>
          </div>
          <div class="metric">
            <span>åœ–ç‰‡æª”æ¡ˆ</span>
            <span class="metric-value" id="image-count">0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="test-section">
      <h2>ğŸ’¡ å„ªåŒ–å»ºè­°</h2>
      <div id="recommendations-container">
        <p>æ­£åœ¨åˆ†ææ•ˆèƒ½æ•¸æ“š...</p>
      </div>
    </div>

    <div class="test-section">
      <h2>ğŸ“ æ¸¬è©¦æ—¥èªŒ</h2>
      <div class="log-container" id="test-log"></div>
      <div style="margin-top: 10px">
        <button class="button" onclick="clearLog()">æ¸…é™¤æ—¥èªŒ</button>
        <button class="button" onclick="downloadLog()">ä¸‹è¼‰æ—¥èªŒ</button>
      </div>
    </div>

    <script>
      class PerformanceTestSuite {
        constructor() {
          this.testLog = [];
          this.metrics = {};
          this.startTime = performance.now();

          this.init();
        }

        init() {
          this.log("ğŸš€ æ•ˆèƒ½æ¸¬è©¦å¥—ä»¶åˆå§‹åŒ–");

          // æª¢æŸ¥å„ªåŒ–æ¨¡çµ„æ˜¯å¦è¼‰å…¥
          this.checkOptimizationModules();

          // é–‹å§‹ç›£æ§æ•ˆèƒ½æŒ‡æ¨™
          this.startMetricsMonitoring();

          // ç›£æ§è³‡æºè¼‰å…¥
          this.monitorResourceLoading();

          // è¨­ç½®å®šæœŸæ›´æ–°
          this.setupPeriodicUpdates();

          this.log("âœ… æ¸¬è©¦å¥—ä»¶åˆå§‹åŒ–å®Œæˆ");
        }

        checkOptimizationModules() {
          // æª¢æŸ¥é—œéµè·¯å¾‘å„ªåŒ–å™¨
          setTimeout(() => {
            const criticalPathStatus = document.getElementById(
              "critical-path-status"
            );
            if (window.criticalPathOptimizer) {
              criticalPathStatus.innerHTML =
                '<span class="status-indicator status-good"></span>å·²è¼‰å…¥';
              this.log("âœ… é—œéµè·¯å¾‘å„ªåŒ–å™¨å·²è¼‰å…¥");
            } else {
              criticalPathStatus.innerHTML =
                '<span class="status-indicator status-error"></span>æœªè¼‰å…¥';
              this.log("âŒ é—œéµè·¯å¾‘å„ªåŒ–å™¨æœªè¼‰å…¥");
            }
          }, 1000);

          // æª¢æŸ¥å»¶é²è¼‰å…¥æ©Ÿåˆ¶
          setTimeout(() => {
            const lazyLoaderStatus =
              document.getElementById("lazy-loader-status");
            if (window.lazyLoader) {
              lazyLoaderStatus.innerHTML =
                '<span class="status-indicator status-good"></span>å·²è¼‰å…¥';
              this.log("âœ… å»¶é²è¼‰å…¥æ©Ÿåˆ¶å·²è¼‰å…¥");
            } else {
              lazyLoaderStatus.innerHTML =
                '<span class="status-indicator status-error"></span>æœªè¼‰å…¥';
              this.log("âŒ å»¶é²è¼‰å…¥æ©Ÿåˆ¶æœªè¼‰å…¥");
            }
          }, 1000);

          // æª¢æŸ¥æ•ˆèƒ½ç›£æ§ç³»çµ±
          setTimeout(() => {
            const performanceMonitorStatus = document.getElementById(
              "performance-monitor-status"
            );
            if (window.performanceMonitor) {
              performanceMonitorStatus.innerHTML =
                '<span class="status-indicator status-good"></span>å·²è¼‰å…¥';
              this.log("âœ… æ•ˆèƒ½ç›£æ§ç³»çµ±å·²è¼‰å…¥");
            } else {
              performanceMonitorStatus.innerHTML =
                '<span class="status-indicator status-error"></span>æœªè¼‰å…¥';
              this.log("âŒ æ•ˆèƒ½ç›£æ§ç³»çµ±æœªè¼‰å…¥");
            }
          }, 1000);
        }

        startMetricsMonitoring() {
          if ("PerformanceObserver" in window) {
            // ç›£æ§ Paint äº‹ä»¶
            const paintObserver = new PerformanceObserver((list) => {
              list.getEntries().forEach((entry) => {
                if (entry.name === "first-contentful-paint") {
                  this.updateMetric("fcp", entry.startTime);
                }
              });
            });
            paintObserver.observe({ entryTypes: ["paint"] });

            // ç›£æ§ LCP
            const lcpObserver = new PerformanceObserver((list) => {
              const entries = list.getEntries();
              const lastEntry = entries[entries.length - 1];
              this.updateMetric("lcp", lastEntry.startTime);
            });
            lcpObserver.observe({ entryTypes: ["largest-contentful-paint"] });

            // ç›£æ§ CLS
            const clsObserver = new PerformanceObserver((list) => {
              let clsValue = 0;
              list.getEntries().forEach((entry) => {
                if (!entry.hadRecentInput) {
                  clsValue += entry.value;
                }
              });
              this.updateMetric("cls", (this.metrics.cls || 0) + clsValue);
            });
            clsObserver.observe({ entryTypes: ["layout-shift"] });

            // ç›£æ§ FID
            const fidObserver = new PerformanceObserver((list) => {
              list.getEntries().forEach((entry) => {
                const fid = entry.processingStart - entry.startTime;
                this.updateMetric("fid", fid);
              });
            });
            fidObserver.observe({ entryTypes: ["first-input"] });
          }

          // ç›£æ§ Navigation Timing
          window.addEventListener("load", () => {
            const navigation = performance.getEntriesByType("navigation")[0];
            if (navigation) {
              const ttfb = navigation.responseStart - navigation.requestStart;
              this.updateMetric("ttfb", ttfb);
            }
          });
        }

        updateMetric(name, value) {
          this.metrics[name] = value;

          const element = document.getElementById(`${name}-value`);
          if (element) {
            let displayValue;
            let className = "metric-value";

            if (name === "cls") {
              displayValue = value.toFixed(4);
              if (value > 0.25) className += " error";
              else if (value > 0.1) className += " warning";
            } else {
              displayValue = `${value.toFixed(2)}ms`;
              const thresholds = {
                fcp: [1500, 2500],
                lcp: [2500, 4000],
                fid: [100, 300],
                ttfb: [200, 500],
              };

              const [good, poor] = thresholds[name] || [1000, 2000];
              if (value > poor) className += " error";
              else if (value > good) className += " warning";
            }

            element.textContent = displayValue;
            element.className = className;
          }

          this.updateOverallGrade();
          this.log(`ğŸ“Š ${name.toUpperCase()}: ${displayValue || value}`);
        }

        updateOverallGrade() {
          const grades = {
            fcp: this.gradeMetric(this.metrics.fcp, [1500, 2500]),
            lcp: this.gradeMetric(this.metrics.lcp, [2500, 4000]),
            cls: this.gradeMetric(this.metrics.cls, [0.1, 0.25], true),
            fid: this.gradeMetric(this.metrics.fid, [100, 300]),
            ttfb: this.gradeMetric(this.metrics.ttfb, [200, 500]),
          };

          const validGrades = Object.values(grades).filter((g) => g !== null);
          if (validGrades.length === 0) return;

          const scoreMap = { Good: 3, "Needs Improvement": 2, Poor: 1 };
          const averageScore =
            validGrades.reduce((sum, grade) => {
              return sum + scoreMap[grade];
            }, 0) / validGrades.length;

          let overall;
          let progress;
          if (averageScore >= 2.5) {
            overall = "Good";
            progress = 100;
          } else if (averageScore >= 1.5) {
            overall = "Needs Improvement";
            progress = 60;
          } else {
            overall = "Poor";
            progress = 30;
          }

          document.getElementById(
            "overall-grade"
          ).textContent = `æ•´é«”è©•ç´š: ${overall}`;
          document.getElementById(
            "overall-progress"
          ).style.width = `${progress}%`;
        }

        gradeMetric(value, thresholds, lowerIsBetter = false) {
          if (value === null || value === undefined) return null;

          const [good, needsImprovement] = thresholds;

          if (lowerIsBetter) {
            if (value <= good) return "Good";
            if (value <= needsImprovement) return "Needs Improvement";
            return "Poor";
          } else {
            if (value <= good) return "Good";
            if (value <= needsImprovement) return "Needs Improvement";
            return "Poor";
          }
        }

        monitorResourceLoading() {
          const updateResourceStats = () => {
            const resources = performance.getEntriesByType("resource");

            let totalSize = 0;
            let cssCount = 0;
            let jsCount = 0;
            let imageCount = 0;

            resources.forEach((resource) => {
              totalSize += resource.transferSize || 0;

              if (resource.name.includes(".css")) cssCount++;
              else if (resource.name.includes(".js")) jsCount++;
              else if (resource.name.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i))
                imageCount++;
            });

            document.getElementById("loaded-resources").textContent =
              resources.length;
            document.getElementById("total-size").textContent =
              this.formatBytes(totalSize);
            document.getElementById("css-count").textContent = cssCount;
            document.getElementById("js-count").textContent = jsCount;
            document.getElementById("image-count").textContent = imageCount;
          };

          // åˆå§‹æ›´æ–°
          setTimeout(updateResourceStats, 1000);

          // å®šæœŸæ›´æ–°
          setInterval(updateResourceStats, 5000);
        }

        setupPeriodicUpdates() {
          setInterval(() => {
            this.generateRecommendations();
          }, 10000);
        }

        generateRecommendations() {
          const recommendations = [];

          if (this.metrics.fcp > 1500) {
            recommendations.push("è€ƒæ…®å…§è¯é—œéµ CSS ä»¥æ”¹å–„é¦–æ¬¡å…§å®¹ç¹ªè£½æ™‚é–“");
          }

          if (this.metrics.lcp > 2500) {
            recommendations.push("å„ªåŒ–æœ€å¤§å…§å®¹å…ƒç´ çš„è¼‰å…¥æ™‚é–“");
          }

          if (this.metrics.cls > 0.1) {
            recommendations.push("æ¸›å°‘ç´¯ç©ç‰ˆé¢åç§»ï¼Œç‚ºå…ƒç´ è¨­å®šå›ºå®šå°ºå¯¸");
          }

          if (this.metrics.fid > 100) {
            recommendations.push("å„ªåŒ– JavaScript åŸ·è¡Œæ™‚é–“ï¼Œè€ƒæ…®ç¨‹å¼ç¢¼åˆ†å‰²");
          }

          const container = document.getElementById(
            "recommendations-container"
          );
          if (recommendations.length > 0) {
            container.innerHTML = `
                        <div class="recommendations">
                            <h3>ğŸ’¡ å»ºè­°å„ªåŒ–é …ç›®</h3>
                            <ul>
                                ${recommendations
                                  .map((rec) => `<li>${rec}</li>`)
                                  .join("")}
                            </ul>
                        </div>
                    `;
          } else {
            container.innerHTML =
              '<p style="color: #4caf50;">âœ… æ•ˆèƒ½è¡¨ç¾è‰¯å¥½ï¼Œæš«ç„¡å„ªåŒ–å»ºè­°</p>';
          }
        }

        formatBytes(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        log(message) {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = `[${timestamp}] ${message}`;
          this.testLog.push(logEntry);

          const logContainer = document.getElementById("test-log");
          logContainer.textContent = this.testLog.slice(-50).join("\n");
          logContainer.scrollTop = logContainer.scrollHeight;
        }

        testCriticalPath() {
          this.log("ğŸ”§ æ¸¬è©¦é—œéµè·¯å¾‘å„ªåŒ–...");

          if (window.criticalPathOptimizer) {
            const report = window.criticalPathOptimizer.getPerformanceReport();
            this.log(`âœ… é—œéµè·¯å¾‘æ¸¬è©¦å®Œæˆï¼Œç­‰ç´š: ${report.grade.overall}`);
          } else {
            this.log("âŒ é—œéµè·¯å¾‘å„ªåŒ–å™¨æœªè¼‰å…¥");
          }
        }

        testLazyLoading() {
          this.log("ğŸ”§ æ¸¬è©¦å»¶é²è¼‰å…¥æ©Ÿåˆ¶...");

          if (window.lazyLoader) {
            const status = window.lazyLoader.getLoadStatus();
            this.log(
              `âœ… å»¶é²è¼‰å…¥æ¸¬è©¦å®Œæˆï¼Œå·²è¼‰å…¥æ¨¡çµ„: ${status.loadedModules.length}`
            );
          } else {
            this.log("âŒ å»¶é²è¼‰å…¥æ©Ÿåˆ¶æœªè¼‰å…¥");
          }
        }

        generateReport() {
          this.log("ğŸ“Š ç”Ÿæˆæ•ˆèƒ½å ±å‘Š...");

          const report = {
            timestamp: new Date().toISOString(),
            metrics: { ...this.metrics },
            testDuration: performance.now() - this.startTime,
            userAgent: navigator.userAgent,
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight,
            },
          };

          console.log("ğŸ“Š æ•ˆèƒ½å ±å‘Š:", report);
          this.log("âœ… å ±å‘Šå·²ç”Ÿæˆï¼Œè«‹æŸ¥çœ‹æ§åˆ¶å°");
        }

        exportData() {
          const data = {
            metrics: this.metrics,
            testLog: this.testLog,
            timestamp: new Date().toISOString(),
          };

          const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: "application/json",
          });

          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `performance-test-${
            new Date().toISOString().split("T")[0]
          }.json`;
          a.click();

          URL.revokeObjectURL(url);
          this.log("ğŸ“ æ¸¬è©¦æ•¸æ“šå·²åŒ¯å‡º");
        }
      }

      // å…¨åŸŸå‡½æ•¸
      function testCriticalPath() {
        window.testSuite.testCriticalPath();
      }

      function testLazyLoading() {
        window.testSuite.testLazyLoading();
      }

      function generateReport() {
        window.testSuite.generateReport();
      }

      function exportData() {
        window.testSuite.exportData();
      }

      function clearLog() {
        window.testSuite.testLog = [];
        document.getElementById("test-log").textContent = "";
      }

      function downloadLog() {
        const logText = window.testSuite.testLog.join("\n");
        const blob = new Blob([logText], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `test-log-${new Date().toISOString().split("T")[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // åˆå§‹åŒ–æ¸¬è©¦å¥—ä»¶
      window.addEventListener("load", () => {
        window.testSuite = new PerformanceTestSuite();
      });
    </script>
  </body>
</html>
